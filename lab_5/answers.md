### Ответы на контрольные вопросы

1. _В чем разница между двоичным и общим семафорами?_

Двоичные семафоры принимают в качестве значений только ноль и единицу (используются для исключения взаимного исполнения участка программы двумя и более процессами), в то время как общие семафоры способны принимать и другие числа (используются для работы с ресурсами, количество которых ограничено).

> Мьютекс отличается от двоичного семафора наличием эксклюзивного владельца у мьютекса. Т.е. если процесс A заблокировал мьтекс, то только он сможет его разблокировать. Бинарный семафор может разблокировать любой процесс.

2. _Чем отличаются `P()` и `V()`-операции от обычных операций увеличения и уменьшения на единицу?_

```cpp
P(s) = s - 1
V(s) = s + 1
```

P: При вызове функция проверяет значение s: если s > 0, то отнимается единица, иначе текущую задачу ставим в конец списка блокированных.

V: Прибавляем единицу.

Операции, определенные над семафорами с учетом вышеизложенного:


- Семафор может быть инициализирован неотрицательным значением.
- Операция P уменьшает значение семафора. Если это значение становится отрицательным, процесс, выполняющий операцию Р, блокируется.
- Операция V увеличивает значение семафора. Если это значение не положительно, то заблокированный операцией Р процесс деблокируется. 

3. _Для чего служит набор программных средств IPC?_

IPC (inter-process communication) служит для обмена данных между потоками одного или разных процессов. 

Получение информации по IPC

```bash
ipcs -l
```

4. _Для чего введены массовые операции над семафорами в ОС UNIX?_

Чтобы избегать тупиковые ситуации, задавать семафорам нужное одинаковое значение и пр.

5. _Каково назначение механизма очередей сообщений?_

Очередь сообщений служит для асинхронного обмена данными между процессами путём передачи сообщений в очередь.

6. _Какие операции над семафорами существуют в ОС UNIX?_

Семафоры можно создать (`semget()`), изменять их значения (`semop`, `semctl`) и удалять (`semctl`). С помощью `semctl` можно ещё и получать информацию о семафорах.

> `semop()` -- атомарная функция, т.е. операция, которая выполняется целиком, либо не выполняется вовсе. Таким образом, над семафором может совершать операции только один процесс за раз.

7. _Каково назначение системного вызова `msgget()`?_

`int msgget(key_t key, int flag)` служит для получения идентификатора очереди сообщений по ключу и с указанным флагом.

> IPC_CREAT служит для создания/подключения, IPC_EXCL служит для проверки на создание (errno устанавливается в EEXIST). Младшие девять бит флага задают права доступа (read, write, execute).

8. _Какие условия должны быть выполнены для успешной постановки сообщения в очередь?_

Условиями успешной постановки сообщения в очередь являются:
- наличие прав процесса по записи в данную очередь сообщений;
- не превышение длиной сообщения заданного системой верхнего предела;
- положительное значение указанного в сообщении типа сообщения.

> Тип сообщения выступает своего рода особым id. Так, например, мы можем фильтровать сообщения при получения с помощью этого самого id. Если при приёме мы указываем в качестве id число 0, то мы будем принимать все сообщения без фильтрации.

9. _Как получить информацию о владельце и правах доступа очереди сообщений?_

Можно воспользоваться ключом IPC_STAT для `int msgctl(int msqid, int cmd, struct msqid_ds *buf)`. Это просто скопирует всю информацию об очереди в буффер. Нужная нам информация лежит в структуре `ipc_perm` в `uid` и в `mode`.

10. _Каково назначение системного вызова `shmget()`?_

`int shmget(key_t key, size_t size, int shmflg)` служит для создания/подключения к области разделяемой между процессами памяти размера `size` по ключу и с указанными флагами. Является самым быстрым способом обмена данными между процессами. Чтобы получить указатель на область, нужно воспользоваться функцией `void *virtaddr = shmat(int shmid, void *daddr, int flags);`